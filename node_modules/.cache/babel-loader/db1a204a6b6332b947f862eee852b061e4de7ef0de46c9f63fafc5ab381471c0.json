{"ast":null,"code":"// Check if NFC is supported and polyfill if necessary\nconst hasNFC = typeof window !== 'undefined' && 'NDEFReader' in window;\nexport const scanNFCTag = async () => {\n  try {\n    if (hasNFC) {\n      const ndef = new window.NDEFReader();\n      await ndef.scan();\n      return new Promise(resolve => {\n        ndef.onreading = ({\n          message\n        }) => {\n          for (const record of message.records) {\n            if (record.recordType === \"text\") {\n              const textDecoder = new TextDecoder();\n              const nfcTagId = textDecoder.decode(record.data);\n              resolve(nfcTagId);\n            }\n          }\n        };\n      });\n    } else {\n      console.log('NFC not supported, using simulation mode');\n      // Simulate an NFC tag reading for demo purposes\n      return Promise.resolve(simulateScan());\n    }\n  } catch (error) {\n    console.error('Error scanning NFC tag:', error);\n    // Fall back to simulation in case of error\n    return simulateScan();\n  }\n};\nexport const writeNFCTag = async tagId => {\n  try {\n    if (hasNFC) {\n      const ndef = new window.NDEFReader();\n      await ndef.write({\n        records: [{\n          recordType: \"text\",\n          data: tagId\n        }]\n      });\n      return true;\n    } else {\n      console.log('NFC not supported, simulating write');\n      return true; // Simulate successful write\n    }\n  } catch (error) {\n    console.error('Error writing to NFC tag:', error);\n    throw error;\n  }\n};\n\n// This is a mock function for demo purposes\nexport const simulateScan = () => {\n  // Generate a random tag ID between 1 and 200\n  const randomId = Math.floor(Math.random() * 200) + 1;\n  return `nfc-${randomId}`;\n};","map":{"version":3,"names":["hasNFC","window","scanNFCTag","ndef","NDEFReader","scan","Promise","resolve","onreading","message","record","records","recordType","textDecoder","TextDecoder","nfcTagId","decode","data","console","log","simulateScan","error","writeNFCTag","tagId","write","randomId","Math","floor","random"],"sources":["/Users/natewardy/Desktop/CenTap/src/services/nfcService.js"],"sourcesContent":["// Check if NFC is supported and polyfill if necessary\nconst hasNFC = typeof window !== 'undefined' && 'NDEFReader' in window;\n\nexport const scanNFCTag = async () => {\n  try {\n    if (hasNFC) {\n      const ndef = new window.NDEFReader();\n      await ndef.scan();\n      \n      return new Promise((resolve) => {\n        ndef.onreading = ({ message }) => {\n          for (const record of message.records) {\n            if (record.recordType === \"text\") {\n              const textDecoder = new TextDecoder();\n              const nfcTagId = textDecoder.decode(record.data);\n              resolve(nfcTagId);\n            }\n          }\n        };\n      });\n    } else {\n      console.log('NFC not supported, using simulation mode');\n      // Simulate an NFC tag reading for demo purposes\n      return Promise.resolve(simulateScan());\n    }\n  } catch (error) {\n    console.error('Error scanning NFC tag:', error);\n    // Fall back to simulation in case of error\n    return simulateScan();\n  }\n};\n\nexport const writeNFCTag = async (tagId) => {\n  try {\n    if (hasNFC) {\n      const ndef = new window.NDEFReader();\n      await ndef.write({\n        records: [{\n          recordType: \"text\",\n          data: tagId\n        }]\n      });\n      return true;\n    } else {\n      console.log('NFC not supported, simulating write');\n      return true; // Simulate successful write\n    }\n  } catch (error) {\n    console.error('Error writing to NFC tag:', error);\n    throw error;\n  }\n};\n\n// This is a mock function for demo purposes\nexport const simulateScan = () => {\n  // Generate a random tag ID between 1 and 200\n  const randomId = Math.floor(Math.random() * 200) + 1;\n  return `nfc-${randomId}`;\n};"],"mappings":"AAAA;AACA,MAAMA,MAAM,GAAG,OAAOC,MAAM,KAAK,WAAW,IAAI,YAAY,IAAIA,MAAM;AAEtE,OAAO,MAAMC,UAAU,GAAG,MAAAA,CAAA,KAAY;EACpC,IAAI;IACF,IAAIF,MAAM,EAAE;MACV,MAAMG,IAAI,GAAG,IAAIF,MAAM,CAACG,UAAU,CAAC,CAAC;MACpC,MAAMD,IAAI,CAACE,IAAI,CAAC,CAAC;MAEjB,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAK;QAC9BJ,IAAI,CAACK,SAAS,GAAG,CAAC;UAAEC;QAAQ,CAAC,KAAK;UAChC,KAAK,MAAMC,MAAM,IAAID,OAAO,CAACE,OAAO,EAAE;YACpC,IAAID,MAAM,CAACE,UAAU,KAAK,MAAM,EAAE;cAChC,MAAMC,WAAW,GAAG,IAAIC,WAAW,CAAC,CAAC;cACrC,MAAMC,QAAQ,GAAGF,WAAW,CAACG,MAAM,CAACN,MAAM,CAACO,IAAI,CAAC;cAChDV,OAAO,CAACQ,QAAQ,CAAC;YACnB;UACF;QACF,CAAC;MACH,CAAC,CAAC;IACJ,CAAC,MAAM;MACLG,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;MACvD;MACA,OAAOb,OAAO,CAACC,OAAO,CAACa,YAAY,CAAC,CAAC,CAAC;IACxC;EACF,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdH,OAAO,CAACG,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;IAC/C;IACA,OAAOD,YAAY,CAAC,CAAC;EACvB;AACF,CAAC;AAED,OAAO,MAAME,WAAW,GAAG,MAAOC,KAAK,IAAK;EAC1C,IAAI;IACF,IAAIvB,MAAM,EAAE;MACV,MAAMG,IAAI,GAAG,IAAIF,MAAM,CAACG,UAAU,CAAC,CAAC;MACpC,MAAMD,IAAI,CAACqB,KAAK,CAAC;QACfb,OAAO,EAAE,CAAC;UACRC,UAAU,EAAE,MAAM;UAClBK,IAAI,EAAEM;QACR,CAAC;MACH,CAAC,CAAC;MACF,OAAO,IAAI;IACb,CAAC,MAAM;MACLL,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;MAClD,OAAO,IAAI,CAAC,CAAC;IACf;EACF,CAAC,CAAC,OAAOE,KAAK,EAAE;IACdH,OAAO,CAACG,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACjD,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAMD,YAAY,GAAGA,CAAA,KAAM;EAChC;EACA,MAAMK,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC;EACpD,OAAO,OAAOH,QAAQ,EAAE;AAC1B,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}